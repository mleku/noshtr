package noistr

import (
	"crypto/rand"
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"

	"github.com/flynn/noise"
	"github.com/minio/sha256-simd"
	"github.com/templexxx/xorsimd"
	"mleku.net/ec"
	"mleku.net/ec/schnorr"
	"mleku.net/ec/secp256k1"
)

func init() {
	// we only need 256 bits for our blocks
	xorsimd.EnableAVX512 = false
}

type cipherFn struct {
	// Sec for the signatures of the HMAC for this connection
	Sec *ec.SecretKey
	// PubkeyBytes is the public key we add before the signature
	PubkeyBytes []byte
	// Secret is a 32 byte secret that is generated by ECDH
	Secret []byte
}

// MessageOverhead is a 32 byte nonce, 4 byte size prefix, 32 byte BIP-340
// pubkey, and 64 byte Schnorr signature for message authentication
const MessageOverhead = 32 + 4 + 8 + 32 + 64

func makeSeed() []byte { return make([]byte, sha256.Size*2+8) }

// Encrypt encrypts the provided plaintext with a nonce and then appends the
// ciphertext to out along with an authentication tag over the ciphertext
// and optional authenticated data.
func (c *cipherFn) Encrypt(out []byte, n uint64,
	ad, plaintext []byte) (ciphertext []byte) {

	messageHash := sha256.Sum256(plaintext)
	var err error
	// Preallocate the buffer required
	pl := len(plaintext)
	adl := len(ad)
	out = make([]byte, pl+adl+MessageOverhead)
	mod := pl % sha256.Size
	div := pl / sha256.Size
	if mod != 0 {
		div++
	}
	// first put the IV in
	var cnt int
	if cnt, err = rand.Read(out[:sha256.Size]); chk.E(err) &&
		cnt != sha256.Size {
		panic(err.Error())
	}
	// add the length prefix
	binary.BigEndian.PutUint32(out[sha256.Size+8:], uint32(pl))
	// generate the cipher counter block seed, which is the IV, the shared
	// secret and a 32 bit value representing the position in the stream (thus
	// limiting message size to 4GiB)
	seed := makeSeed()
	// first the IV
	copy(seed, out[:sha256.Size])
	// second the secret
	copy(seed[sha256.Size:], c.Secret)
	// start the encryption loop
	var i uint64
	end := uint64(pl)
	// offset is the starting point for each block
	offset := sha256.Size*2 + 4
	var pt []byte
	var rem int
	for ; i < end; i++ {
		if i+1 != end {
			// on non-end blocks we can read directly from the source
			pt = plaintext[i*sha256.Size : (i+1)*sha256.Size]
		} else {
			// add the extra bytes so the xor only has to handle equal length
			pt = make([]byte, sha256.Size)
			rem = pl - int(i)*sha256.Size
			// the last time we must use a copy so the xor is faster
			copy(pt[:rem], plaintext[i*sha256.Size:])
		}
		blockHash := sha256.Sum256(seed)
		// XOR in the plaintext
		xorsimd.Bytes(out[offset:offset+sha256.Size], blockHash[:], pt)
		// bump the seed
		binary.BigEndian.PutUint64(seed[sha256.Size*2:], i+1)
		// bump the offset
		if i+1 != end {
			offset += sha256.Size
		} else {
			// if it is at the end, bump to the end
			offset += rem
		}
	}
	// next, the Additional Data
	copy(out[offset:offset+adl], c.PubkeyBytes)
	offset += adl
	// next the public key we are signing with (session key)
	copy(out[offset:offset+sha256.Size], c.PubkeyBytes)
	offset += sha256.Size
	// and lastly, sign
	var sig *schnorr.Signature
	if sig, err = schnorr.Sign(c.Sec, messageHash[:]); chk.E(err) {
		return
	}
	copy(out[offset:], sig.Serialize())
	return out
}

// Decrypt authenticates the ciphertext and optional authenticated data and
// then decrypts the provided ciphertext using the provided nonce and
// appends it to out.
func (c *cipherFn) Decrypt(out []byte, n uint64,
	ad, ciphertext []byte) (plaintext []byte, err error) {

	if len(ciphertext) < sha256.Size+4 {
		err = errors.New("message is shorter than the header")
		return
	}
	// next get the message length
	msgLen := int(binary.BigEndian.Uint32(ciphertext[sha256.Size : sha256.Size+4]))
	// check that this information is at least correct on the long side
	if msgLen+MessageOverhead < len(ciphertext)+schnorr.PubKeyBytesLen+
		schnorr.SignatureSize {

		err = fmt.Errorf("message less than minimum, got %d, expected %d",
			len(ciphertext), msgLen+MessageOverhead)
		return
	}
	seed := makeSeed()
	// copy over the IV
	copy(seed[:sha256.Size], ciphertext[:sha256.Size])
	// copy the secret
	copy(seed[sha256.Size:], c.Secret)
	// offset is the starting point for the message
	offset := sha256.Size*2 + 4
	// first check the signature
	messageHash := sha256.Sum256(ciphertext[offset : offset+msgLen])
	// get the signature and pubkey
	sigStart := len(ciphertext) - schnorr.SignatureSize
	sigBytes := ciphertext[sigStart:]
	pubBytes := ciphertext[sigStart-schnorr.PubKeyBytesLen : sigStart]
	var sig *schnorr.Signature
	if sig, err = schnorr.ParseSignature(sigBytes); chk.E(err) {
		return
	}
	var pub *ec.PublicKey
	if pub, err = schnorr.ParsePubKey(pubBytes); chk.E(err) {
		return
	}
	if !sig.Verify(messageHash[:], pub) {
		err = fmt.Errorf("failed to verify signature of message: pubkey: %s",
			hex.EncodeToString(pubBytes))
		return
	}
	// authenticity checks out, now try to decrypt
	//
	// decryption is literally the same as encryption, this is CTR
	var i uint64
	var pt []byte
	var rem int
	end := uint64(msgLen)
	for ; i < end; i++ {
		if i+1 != end {
			// on non-end blocks we can read directly from the source
			pt = ciphertext[i*sha256.Size : (i+1)*sha256.Size]
		} else {
			// add the extra bytes so the xor only has to handle equal length
			pt = make([]byte, sha256.Size)
			rem = msgLen - int(i)*sha256.Size
			// the last time we must use a copy so the xor is faster
			copy(pt[:rem], ciphertext[i*sha256.Size:])
		}
		blockHash := sha256.Sum256(seed)
		// XOR in the plaintext
		xorsimd.Bytes(out[offset:offset+sha256.Size], blockHash[:], pt)
		// bump the seed
		binary.BigEndian.PutUint64(seed[sha256.Size*2:], i+1)
		// bump the offset
		if i+1 != end {
			offset += sha256.Size
		} else {
			// if it is at the end, bump to the end
			offset += rem
		}
	}
	adr := make([]byte, offset-msgLen)
	copy(ad, ciphertext[offset:offset+msgLen])
	// todo: additional data should match something? this doesn't seem relevant
	_ = adr

	plaintext = out
	return
}

// Cipher initializes the algorithm with the provided key and returns a Cipher.
func (c *cipherFn) Cipher(k [32]byte) (ciph noise.Cipher) {
	c.Secret = k[:]
	// generate a cipher secret for the HMAC signatures
	var err error
	b := make([]byte, secp256k1.SecKeyBytesLen)
	if _, err = rand.Read(b); chk.E(err) {
		return
	}
	// load the HMAC keys
	var pk *ec.PublicKey
	c.Sec, pk = ec.SecKeyFromBytes(b)
	c.PubkeyBytes = schnorr.SerializePubKey(pk)
	return c
}

// CipherName is the name of the cipher.
func (c *cipherFn) CipherName() string { return "chachapoly20" }
