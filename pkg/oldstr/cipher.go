package oldstr

import (
	"bytes"
	"encoding/binary"

	"github.com/flynn/noise"
	"github.com/minio/sha256-simd"
	"github.com/templexxx/xorsimd"
	"mleku.net/ec"
	"mleku.net/ec/schnorr"
)

func init() {
	// we only need 256 bits for our blocks
	xorsimd.EnableAVX512 = false
}

type cipherFn struct {
	// Sec for the signatures of the HMAC for this connection
	Sec *ec.SecretKey
	// SecBytes is the raw bytes
	SecBytes []byte
	// PubkeyBytes is the public key we add before the signature
	PubkeyBytes []byte
	// Secret is a 32 byte secret that is generated by ECDH
	Secret []byte
}

var CipherSHA256CTR cipherFn

// HeaderLen is the length of the header, it contains the 32 byte IV and a 4
// byte, 32 bit message length prefix.
const HeaderLen = sha256.Size + 4

// FooterLen is the length of the last piece of the message, the BIP-340 public
// key and the schnorr signature.
const FooterLen = schnorr.PubKeyBytesLen +
	schnorr.SignatureSize

// MessageOverhead is a 32 byte nonce, 4 byte size prefix, 32 byte BIP-340
// pubkey, and 64 byte Schnorr signature for message authentication
const MessageOverhead = HeaderLen + FooterLen

// Cipher initializes the algorithm with the provided key and returns a Cipher.
func (c cipherFn) Cipher(secret [32]byte) (ciph noise.Cipher) {
	// load in the symmetric secret key used in the CTR encryption
	c.Secret = secret[:]
	// generate a cipher secret for the HMAC signatures
	var err error
	if c.Sec, err = ec.NewSecretKey(); chk.E(err) {
		return
	}
	pk := c.Sec.PubKey()
	// load the HMAC keys
	c.SecBytes = c.Sec.Serialize()
	c.PubkeyBytes = schnorr.SerializePubKey(pk)
	return c
}

// CipherName is the name of the cipher.
func (c cipherFn) CipherName() string { return "sha256ctr" }

// CTR is a counter mode encryption based on a seed, the IV, shared secret and a
// 32 bit counter value, hashing with SHA256 and XOR with the block in the
// message.
//
// This function is identical for encryption and decryption
func (c cipherFn) CTR(text, seed []byte) {
	var offset int
	var i int
	l := len(text)
	mod := l % sha256.Size
	div := l / sha256.Size
	if mod != 0 {
		div++
	}
	bLen := sha256.Size
	for ; i < div; i++ {
		if mod != 0 {
			if int(i)+1 == div {
				bLen = mod
			}
		}
		blockHash := sha256.Sum256(seed)
		// XOR in the plaintext
		xorsimd.Bytes(text[offset:offset+bLen],
			blockHash[:], text[offset:offset+bLen])
		// bump the seed
		binary.BigEndian.PutUint64(seed[sha256.Size*2:], uint64(i)+1)
		// bump the offset
		offset += bLen
	}
	Zero(seed)
	return
}

func makeSeed() []byte { return make([]byte, sha256.Size*2+8) }

func GenerateSeed(iv, secret []byte) (seed []byte) {
	seed = makeSeed()
	buf := bytes.NewBuffer(seed)
	// first the IV
	buf.Write(iv[:sha256.Size])
	// second the secret (the first count is zero so it's done)
	buf.Write(secret)
	return
}

// Zero uses xorsimd to xor the bytes to themselves thus zeroing them
func Zero(b []byte) { xorsimd.Bytes(b, b, b) }
